# Architectural documentation

`Tagger` is a simple application created to showcase `Servant` and how to integrate it into a working application.

The project is structured in three layers:
- the `Tagger` folder contains the domain of the application;
- the `Infrastructure` folder contains the implementations of the relevant services need by the application;
- the `Api` folder contains the application layer which connects the external world and the previous two layers.

There is a dependency between the layers which works as follows

```mermaid
graph TD;
  Infrastructure --> Domain;
  Application --> Infrastructure;
  Application --> Domain;
```

where each arrow denotes an allowed dependency.

In other words, the `Domain` of the application can never access either the `Infrastructure` or the `Application` layer. The `Infrastructure` layer can only access the `Domain` layer and the `Application` layer has actually access to everything.

## Domain

The domain of the application contains the relevant domain entities, as `Content`, `Tag` and `User`.

Identifiers of domain entities are not included in the entities themselves and are instead managed using an `Id` data type, which has a phantom type used to specify which entity it is actually identifying.

The domain layer contains also the [repositories](https://www.martinfowler.com/eaaCatalog/repository.html) to interact with collections of domain objects. At the domain level, we have only the interface of the repositories, working in a generic context `m`.

## Infrastructure

The infrastructure layer provides the implementations needed by the application. Specifically it provides access to the database, to error logging and user authentication.

### Persistence

Contains the implementation, based on `PostgreSQL`, of the repositories defined in the domain layer.

In the concrete implementations we specialize the context `m` of the repositories to `ExceptT QueryError IO` so that we can work in a concrete monad.

The repositories are combining the queries defined at the database level and are using the serialization/unserialization mechanism to convert between the domain entities and their representation at the database level.

### Logging

Provides to the application the ability of logging error messages.

### Authentication

It contains two services, `PasswordManager` and `AuthenticateUser`, where the latter is using the former.

Being infrastructural services their interface and implementation are defined together in the same module.

## Application

The application layer deals mainly with two issues:
- setting up all the services required by the application
- describing the API of the application

### Services

The `AppServices` modules deals with building all the required services and packing them all together.

To do this we first need to choose an explicit implementation for each service.

At this level we want all the services to work directly in the `Handler` monad. This requires us to hoist the services from the concrete context where they are initially defined to `Handler`.

Doing so implies that we also need to handle the errors generated by the services. Hence at this point we decide how to log the error messages and which status code is appropriate for every specific error.

### API definition

Once we setup all the required services, we can pass them to the API endpoints which are defined in the `Application` module.

We make use of Servant `NamedRoutes` to define our API is a clear and composable way, splitting their respective handlers in several modules.

### Configuration

Another issue which is dealt with at the application level is configuration.

We define the schema of the required configuration and a bidirectional codec.
